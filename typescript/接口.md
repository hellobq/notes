### interface 接口

interface 主要起到规范的作用，与 abstract 相似，但强于 abstract 的约束能力：
- 对类的一部分进行抽象，限制了类。
- 不同类之间的共性由接口来管理。

比如：Cat、Dog 类都有 eat 方法，可以把 eat 方法交由接口来规范。

``` ts
interface Eat {
  eat(): void;
}

class Cat implements Eat {
  eat(): void {
    console.log('cat eat');
  }
}

class Dog implements Eat {
  eat(): void {
    console.log('dog eat');
  }
}
```

对于类来说，需要实现（implements）接口；对于接口来说，只能继承。

### 接口继承接口

接口继承接口，子接口会有更多未实现的方法，因此需要实现它的类去做更多的实现。

``` ts
interface Eat {
  eat(): void;
}

interface EatWays extends Eat{
  bigEat(): void;
  smallEat(): void;
}

class Cat implements EatWays {
  eat(): void {
    console.log('cat eat');
  }

  bigEat(): void {
    console.log('cat big-eat');
  }

  smallEat(): void {
    console.log('cat small-eat');
  }
}

class Dog implements EatWays {
  eat(): void {
    console.log('dog eat');
  }

  bigEat(): void {
    console.log('dog big-eat');
  }

  smallEat(): void {
    console.log('dog small-eat');
  }
}
```

### 一个类实现多个接口

一个类可实现多个接口，用逗号隔开。这样给类扩大了功能。

``` ts
interface Eat {
  eat(): void;
  food: string;
}

interface Drink {
  drink(): void;
}

class Cat implements Eat, Drink {
  food: string = 'food';

  eat(): void {
    console.log('cat eat');
  }

  drink(): void {
    console.log('cat drink');
  }
}
```

### 接口继承类

接口不仅可继承其他接口来扩大自己的规范行为，也可以继承类。

``` ts

interface Eat extends Animal {
  age: number;
}

const eat: Eat = {name: 'baba', age: 20};
```

### 使用接口规范函数

规范函数所需参数类型、返回值类型等。

``` ts
interface FullName {
  (startName: string, endName: string): string;
}

const getFullName: FullName = <FullName>(startName: string, endName: string) =>  startName + endName;
```

``` ts
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = <Counter>function (start: number) { };
  counter.interval = 123;
  counter.reset = function () { };
  return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

### 使用接口规范一个具体的类

包括类的属性、方法。

``` ts
interface FullName {
  getName (otherStr: string): string;
  startName: string;
  endName?: string;
}

class Name implements FullName {
  startName: string;
  endName: string;

  constructor (startName: string, endName: string) {
    this.startName = startName;
    this.endName = endName;
  }

  getName(otherStr: string): string {
    return this.startName + this.endName + otherStr;
  }
  
}

alert( new Name('Jack', 'hahah').getName('lalal') );
```
